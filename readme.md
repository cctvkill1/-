啊哈！算法 
========
上传一些代码及自己的看法
------------
###2016-7-11
快速排序<br/>
数组中找个基数，将基数定位，然后基数左右两边的递归此方法，知道两边都排序<br/>
时间复杂度最差的时候和冒泡排序一样 都是O(N²) 平均是O(NlogN) 差不多是6点几(N为10)<br/>
找到原书18页有个left>right的bug 应该是>=<br/> 
php有个简单写法 但是速度不快<br/> 
###2016-7-12
队列、栈
###2016-7-13
链表
###2016-7-14
火柴棍等式 就是枚举 <br>
全队列 和 □□□+□□□=□□□等式 简单的深度优先 <br>
这节主要是理解depth first search.DFS 深度优先搜索的基本理念<br>
关键在于‘当下这一步该怎么做’，‘至于下一步怎么做’ 则与 ‘当下这一步该怎么做’ 一样<br>
注意book[x] = 0的那一步
###2016-7-19
解救小哈<br>
一张二维数组中找小哈(深度优先搜索)，0为空地，1为障碍<br>
第一步 出发点都尝试上下左右走一步，然后每一步再作为出发点，dfs 一直递归 一条路走到头<br>
直到找到小哈并比较最短路径是不是最小 没找到则退回上一个点 然后重新尝试第一步
深度优先搜索: 约翰·霍普克洛夫特和罗伯特·陶尔扬在1971年发明此算法
###2016-7-20
解救小哈 题目和昨天一样<br>
一张二维数组中找小哈(广度优先搜索)，0为空地，1为障碍<br>
通过 一层一层的扩展，扩展时每发现一个点就加入队列，直到找打小哈 <br>
第一步 出发点 扩展 尝试上下左右走一步 将每一步加入队列 ，判断找到小哈 <br>
没有继续 扩散 重复第一步 走过的和出界的不加入队列 直到找到小哈<br>
广度优先搜索：Edward F.Moore 在1959年率先提出
###2016-7-21
炸弹人 （上次炸弹人解出来地图上哪一点灭最多，但是没有判断这个点是否可以走过去）<br>
利用广度优先搜索 探路 然后再计算每一步炸多少敌人 记录最多的位置

